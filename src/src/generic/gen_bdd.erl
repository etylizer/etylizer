-module(gen_bdd).
-vsn({2,0,0}).

% A generic BDD parameterized over both the 'nodes and 'leafs: BDD<Element, Terminal>
%
% The BDD is parameterized over the implementation module variables:
% $Terminal implements type and eq
% $Element implements eq
%
% 'Element' and 'Terminal' are reserved variable names
% This module assumes they implement callbacks of the respective modules
%
% A BDD represents a DNF of 'nodes intersected with a terminal type generated by a 'leaf.
% A leaf itself can be a DNF (e.g. for functions or tuples), or a compact representation for a basic type (e.g. atoms).
%
% Used to represent a DNF of variables where each co-clause is intersected with a DNF of a nested kind
% and a DNF of variables with compact leaf nodes for intervals, specials, and atoms.

%%-type terminal() :: any(). % :: Terminal:type()
%%-type element() :: any().  % :: Element:type()
%%-type bdd() :: 0 | {terminal, terminal()} | {node, element(), bdd(), bdd()}.

%%-behavior(type). % implements type behavior indirectly parameterized over a type
-export([terminal/2, element/2, empty/1, any/1, union/3, intersect/3, negate/2, diff/3, eval/2, is_empty/2, is_any/2]).

%%-behavior(eq). % implements eq behavior indirectly parameterized over a type
-export([equal/3, compare/3]).

% ==
% basic interface (parameterized)
% ==
equal(Gen = {_, Element}, {node, E1, A1, B1}, {node, E2, A2, B2}) ->
    Element:equal(E1, E2)
    andalso equal(Gen, A1, A2)
    andalso equal(Gen, B1, B2);
equal({Terminal, _}, {terminal, T1}, {terminal, T2}) ->
  Terminal:equal(T1, T2);
equal(_, _, _) ->
  false.

compare({Terminal, _}, {terminal, T1}, {terminal, T2}) -> Terminal:compare(T1, T2);
compare(_, 0, {terminal, _}) -> -1;
compare(_, {terminal, _}, 0) -> +1;
compare(_, {terminal, _}, {node, _, _, _}) -> +1;
compare(_, {node, _, _, _}, {terminal, _}) -> -1;
compare(Gen = {_, Element}, {node, E1, A1, B1}, {node, E2, A2, B2}) ->
  case Element:compare(E1, E2) of
    0 ->
      case compare(Gen, A1, A2) of
        0 -> compare(Gen, B1, B2);
        Res -> Res
      end;
    Res -> Res
  end.

% ==
% type interface
% ==
empty(_) -> 0.
any({Terminal, _}) -> {terminal, Terminal:any()}.

element(I = {_Terminal, _Element}, Atom) ->
  s(I, {node, Atom, any(I), empty(I)}).

terminal(I = {_Terminal, _}, Ty) ->
  terminal_of(I, Ty).


union(_, 0, B) -> B;
union(_, A, 0) -> A;
union(I = {Terminal, Element}, A, B) ->
  case is_any(I, A) orelse is_any(I, B) of
    true -> any(I);
    _ ->
      case {A, B} of
        {{terminal, X}, {terminal, Y}} -> terminal_of(I, Terminal:union(X, Y));
        {BDD1 = {node, E, A1, B1}, BDD2 = {node, E2, A2, B2}} ->
          case Element:compare(E, E2) of
            -1 ->
              s(I,{node, E, s(I,union(I, A1, BDD2)), s(I,union(I, B1, BDD2))});
            +0 ->
              s(I,{node, E, s(I,union(I, A1, A2)), s(I,union(I, B1, B2))});
            +1 ->
              s(I,{node, E2, s(I,union(I, A2, BDD1)), s(I,union(I, B2, BDD1))})
          end;
        {BDD1 = {terminal, _X}, _BDD2 = {node, E2, A2, B2}} ->
          s(I, {node, E2, s(I, union(I, A2, BDD1)), s(I, union(I, B2, BDD1))});
        {_BDD1 = {node, E1, A1, B1}, BDD2 = {terminal, _X}} ->
          s(I, {node, E1, s(I, union(I, A1, BDD2)), s(I, union(I, B1, BDD2))})
      end
  end.

negate(I, 0) -> any(I);
% FIXME HACK why is this branch reached? it should always be a {terminal, 1}, not a raw 1
negate(_I, 1) -> 0;
negate(I = {Terminal, _}, TN = {terminal, A}) ->
  case is_any(I, TN) of
    true -> 0;
    _ -> s(I, {terminal, Terminal:negate(A)})
  end;
negate(I, {node, E, B1, B2}) -> s(I, {node, E, s(I, negate(I, B1)), s(I, negate(I, B2))}).


diff(I, A, B) -> intersect(I, A, negate(I, B)).
intersect(I, A, B) -> negate(I, union(I, negate(I, A), negate(I, B))).


is_any({Terminal, _}, {terminal, Ty}) -> Terminal:equal(Ty, Terminal:any());
is_any(_, _) -> false.


% TODO
eval(_,_) -> erlang:error("TODO").

% convert empty terminal node into empty BDD node
terminal_of({Terminal, _}, Ty) ->
  case Terminal:equal(Ty, Terminal:empty()) of
    true -> 0;
    _ -> {terminal, Ty}
  end.


s(_G, {node, _, B, B}) -> B;
s(_G, X) -> X.

is_empty(P, _) -> erlang:error({"implement above", P}).
