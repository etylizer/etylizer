% A generic BDD parameterized over both the 'nodes and 'leafs: BDD<Element, Terminal>
%
% The BDD is parameterized over the implementation module variables:
% ?TERMINAL implements type and equality methods
% ?ELEMENT implements equality methods
%
% A BDD represents a DNF of 'nodes intersected with a terminal type generated by a 'leaf.
% A leaf itself can be a DNF (e.g. for functions or tuples), or a compact representation for a basic type (e.g. atoms).
%
% Used to represent a DNF of variables where each co-clause is intersected with a DNF of a nested kind
% and a DNF of variables with compact leaf nodes for intervals, specials, and atoms.

% hide built-in Erlang node function
-compile({no_auto_import, [node/1]}).

-export([get_dnf/1, any/0, empty/0, equal/2, node/1, terminal/1, compare/2, union/2, intersect/2, negate/1]).
-export([to_dnf/1]).

-include("generic_dnf.hrl").

% these are defined here so the IDE does not complain
-ifndef(ELEMENT).
-define(ELEMENT, ty_bool).
-endif.
-ifndef(TERMINAL).
-define(TERMINAL, ty_bool).
-endif.

any() -> {terminal, ?TERMINAL:any()}.
empty() -> {terminal, ?TERMINAL:empty()}.

equal({node, E1, A1, B1}, {node, E2, A2, B2}) ->
  ?ELEMENT:equal(E1, E2)
    andalso equal(A1, A2)
    andalso equal(B1, B2);
equal({terminal, T1}, {terminal, T2}) ->
  ?TERMINAL:equal(T1, T2);
equal(_, _) ->
  false.

node(Node) -> s({node, Node, any(), empty()}).
terminal(Ty) -> terminal_of(Ty).

terminal_of(Ty) ->
  case ?TERMINAL:equal(Ty, ?TERMINAL:empty()) of
    true -> {terminal, ?TERMINAL:empty()};
    _ ->
      case ?TERMINAL:equal(Ty, ?TERMINAL:any()) of
        true -> {terminal, ?TERMINAL:any()};
        _ ->
          {terminal, Ty}
      end
  end.

s({node, _, B, B}) -> B;
s(X) -> X.

% TODO currently unused, when to use?
compare({terminal, T1}, {terminal, T2}) -> ?TERMINAL:compare(T1, T2);
compare({terminal, _}, {node, _, _, _}) -> +1;
compare({node, _, _, _}, {terminal, _}) -> -1;
compare({node, E1, A1, B1}, {node, E2, A2, B2}) ->
  case ?ELEMENT:compare(E1, E2) of
    0 ->
      case compare(A1, A2) of
        0 -> compare(B1, B2);
        Res -> Res
      end;
    Res -> Res
  end.

union(A, B) ->
  case s_is_empty(A) of
    true -> B;
    _ ->
      case s_is_empty(B) of
        true -> A;
        _ ->
          case s_is_any(A) orelse s_is_any(B) of
            true -> any();
            _ ->
              case {A, B} of
                {{terminal, X}, {terminal, Y}} -> terminal_of(?TERMINAL:union(X, Y));
                {BDD1 = {node, E, A1, B1}, BDD2 = {node, E2, A2, B2}} ->
                  case ?ELEMENT:compare(E, E2) of
                    -1 ->
                      s({node, E, union(A1, BDD2), union(B1, BDD2)});
                    +0 ->
                      s({node, E, union(A1, A2), union(B1, B2)});
                    +1 ->
                      s({node, E2, union(A2, BDD1), union(B2, BDD1)})
                  end;
                {BDD1 = {terminal, _X}, _BDD2 = {node, E2, A2, B2}} ->
                  s({node, E2,  union(A2, BDD1),  union(B2, BDD1)});
                {_BDD1 = {node, E1, A1, B1}, BDD2 = {terminal, _X}} ->
                  s({node, E1,  union(A1, BDD2),  union(B1, BDD2)})
              end
          end
      end
  end.

intersect(A, B) ->
  case s_is_any(A) of
    true -> B;
    _ ->
      case s_is_any(B) of
        true -> A;
        _ ->
          case s_is_empty(A) orelse s_is_empty(B) of
            true -> empty();
            _ ->
              case {A, B} of
                {{terminal, X}, {terminal, Y}} -> terminal_of(?TERMINAL:intersect(X, Y));
                {BDD1 = {node, E, A1, B1}, BDD2 = {node, E2, A2, B2}} ->
                  case ?ELEMENT:compare(E, E2) of
                    -1 ->
                      s({node, E, intersect(A1, BDD2), intersect(B1, BDD2)});
                    +0 ->
                      s({node, E, intersect(A1, A2), intersect(B1, B2)});
                    +1 ->
                      s({node, E2, intersect(A2, BDD1), intersect(B2, BDD1)})
                  end;
                {BDD1 = {terminal, _X}, _BDD2 = {node, E2, A2, B2}} ->
                  s({node, E2, intersect(A2, BDD1), intersect(B2, BDD1)});
                {_BDD1 = {node, E1, A1, B1}, BDD2 = {terminal, _X}} ->
                  s({node, E1, intersect(A1, BDD2), intersect(B1, BDD2)})
              end
          end
      end
  end.

negate({terminal, A}) ->
  s({terminal, ?TERMINAL:negate(A)});
negate({node, E, B1, B2}) -> s({node, E, s(negate(B1)), s(negate(B2))}).

s_is_any({terminal, Ty}) -> ?TERMINAL:equal(Ty, ?TERMINAL:any());
s_is_any(_) -> false.

s_is_empty({terminal, Ty}) -> ?TERMINAL:equal(Ty, ?TERMINAL:empty());
s_is_empty(_) -> false.

is_empty_union(F1, F2) ->
  F1() andalso F2().

get_dnf(Bdd) ->
  lists:filter(
    fun({_,_,[]}) -> false; ({_, _, T}) ->
      case ?TERMINAL:empty() of
        T -> false;
        _ ->  true
      end
    end,
    dnf(Bdd, {fun(P, N, T) -> [{P, N, T}] end, fun(C1, C2) -> C1() ++ C2() end})
  ).

dnf(Bdd, {ProcessCoclause, CombineResults}) ->
  do_dnf(Bdd, {ProcessCoclause, CombineResults}, _Pos = [], _Neg = []).

do_dnf({node, Element, Left, Right}, F = {_Process, Combine}, Pos, Neg) ->
  % heuristic: if Left is positive & 1, skip adding the negated Element to the right path
  % TODO can use the see simplifications done in ty_rec:transform to simplify DNF before processing?
  case {terminal, ?TERMINAL:any()} of
    Left ->
      F1 = fun() -> do_dnf(Left, F, [Element | Pos], Neg) end,
      F2 = fun() -> do_dnf(Right, F, Pos, Neg) end,
      Combine(F1, F2);
    _ ->
      F1 = fun() -> do_dnf(Left, F, [Element | Pos], Neg) end,
      F2 = fun() -> do_dnf(Right, F, Pos, [Element | Neg]) end,
      Combine(F1, F2)
  end;
do_dnf({terminal, Terminal}, {Proc, _Comb}, Pos, Neg) ->
  Proc(Pos, Neg, Terminal).

to_dnf([]) -> ?TERMINAL:empty();
to_dnf([{Pos, Neg} | Rest]) ->
  P = [node(P) || P <- Pos],
  N = [node(N) || N <- Neg],

  Pclause = lists:foldl(fun(E, Acc) -> intersect(E, Acc) end, ?TERMINAL:any(), P),
  Nclause = lists:foldl(fun(E, Acc) -> intersect(negate(E), Acc) end, ?TERMINAL:any(), N),
  Clause = intersect(Pclause, Nclause),
  union(Clause, to_dnf(Rest)).
  